import Data.Set (Set)
import qualified Data.Set as Set

type ExtensionCriteria a = [Integer] -> a -> Integer -> Bool
type TableUpdate a = Integer -> [Integer] -> a -> a

a338013 :: Int -> Integer
a338013 n = a338013_list !! (n-1)

a338013_list :: [Integer]
a338013_list = missingFromTables [(+), (*)] a338012_list

a338012_list :: [Integer]
a338012_list = delahayeList 0 (Set.singleton 0) validA338012 updateA338012Table

validA338012 knownTerms table k = disjointColumns && trivialIntersection where
  aColumn = column (+) knownTerms k
  mColumn = column (*) knownTerms k
  disjointColumns = Set.disjoint aColumn mColumn
  newValues = Set.union aColumn mColumn
  trivialIntersection = Set.singleton 0 == Set.intersection table newValues

updateA338012Table k knownTerms table = table' where
  table' = foldr1 Set.union [table, column (+) knownTerms k, column (*) knownTerms k]

delahayeList :: Integer -> a -> ExtensionCriteria a -> TableUpdate a -> [Integer]
delahayeList k initialTable isValidExtension updateTable = thisList where
  thisList = k : recurse 1 initialTable where
    recurse n table = nextTerm : recurse (n+1) (updateTable nextTerm knownTerms table) where
      knownTerms = take n thisList
      nextTerm = head $ filter (isValidExtension knownTerms table) [maximum knownTerms + 1 ..]

column :: (Integer -> Integer -> Integer) -> [Integer] -> Integer -> Set Integer
column f knownTerms k = Set.fromList (map (f k) (k:knownTerms))

missingFromTables :: [Integer -> Integer -> Integer] -> [Integer] -> [Integer]
missingFromTables operations sequence = recurse 1 sequence Set.empty [] where
  recurse lower (n:ns) table knownTerms = newValues ++ recurse n ns table' (n:knownTerms) where
    table' = foldr1 Set.union (table : map (\f -> column f knownTerms n) operations)
    newValues = Set.toAscList $ Set.difference (Set.fromList [lower..n-1]) table
